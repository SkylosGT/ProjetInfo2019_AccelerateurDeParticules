QUESTIONS P1.1
On a représenté les vecteurs3D comme une classe ayant comme attributs privés ces trois coordonnées de types double. Les méthodes publiques utiles sont les getters (pour accéder aux coordonnes), les setters, pour initialiser un vecteur (mais pas très bien car risque d'oublie et mauvaise initialisation possible, que se passe t'il sans initialisation?). D'autres méthodes utiles sont l'affichage et la comparaison de deux vecteurs mise en publique afin de pouvoir y accéder.

QUESTION P4.1
Le constructeur de copie par défaut offert par C++ fait une copie de surface : il recopie la valeur des attributs dans le nouvel objet. Dans notre classe Vecteur3D, ce constructeur de copie est donc nettement suffisant. On n'a en effet besoin que de la copie des coordonnées du vecteur. Il est donc (pour l'instant en tout cas) inutile de créer une version plus avancée qui implique notamment la redéfinition du destructeur et de l'opérateur d'affectation.

QUESTION P4.2
Si on rajoutait un constructeur en coordonnée sphérique, il faudrait déjà différencier l'initialisation de celui-ci par rapport à une initialisation en coordonnées cartésiennes à l'aide par exemple un booléen passé en argument. Ce nouveau constructeur apporterait de l'ambiguïté dans notre classe puisque : 
-les attributs n'aurait plus de réel signification puisqu'ils pourraient porté la valeur d'un vecteur en coordonnées sphériques ou cartésien 
-un vecteur est lié dans sa représentation à une base de coordonnée dans lequel il est décrit et où l'on fait des opérations. Permettre l'ajout d'une nouvelle base dans notre classe serait très compliqué et rendrait l'implémentation et l'utilisation des opérateurs ambigüe et difficile.

QUESTION P4.3
Nous avons introduit une surcharge de l'opérateur de sortie << afin de remplacer la fonction affichage ainsi qu'une surcharge de l'opérateur de comparaison == à la place de la fonction de comparaison.

QUESTION P5.1
Nous avons implémenter la fonction gamma et l'énergie comme méthodes ne modifiant aucun attribut et retournant un double. Le facteur gamma ainsi que l'énergie se calculent en tout temps respectivement en fonction de la vitesse instantanée de la particule et de la vitesse et masse de la particule. Ces choix d'implémentation reflète seulement notre vision de la conception : il nous paraît plus correct physiquement parlant de séparer les attributs "de base" d'une particule tels que sa vitesse, sa position, sa charge et sa masse, de ses méthodes gamma et énergie plus complexes à calculer, propre à nos particules (l'énergie ne se calcule pas aussi facilement pour tout objet subissant des forces) et utilisant les attributs de base. 
De plus, si nous avions choisi d'implémenter gamma et énergie en attributs, les calculs de ceux-ci devrait se réitérer en tout temps voulu (ils prennent différentes valeur à chaque fois que la particule bouge) d'une façon ou d'une autre dans un bout du code pour après stocker le résultat dans l'attribut. Cela ne fait qu'augmenter le codage inutile et l'ambiguïté de notre classe.

QUESTION P6.1
Il parait assez évident qu'il est nécessaire avant de créer des classes élément courbe et droit, de créer une super-classe Element dont elles hériteront. En effet, les éléments droits et courbes différent déjà juste par leur géométrie, mais elles restent des éléments ayant des attributs et des méthodes en commun.
Dans la super-classe Element, on définit, comme l'indique l'énoncé de l'exercice, les attributs suivants qui seront hérités dans chaque sous-classe d'élément: un vecteur3D représentant la position d'entrée de l'élément, au autre pour sa position de sortie, un scalaire représentant le rayon de la chambre à vide, et enfin un pointeur à la C (plus de liberté mais il faudra faire attention à ne pas utiliser un pointeur ne pointant sur rien "segmentation fault") sur l'élément suivant.

QUESTION P6.2
Les champs magnétiques sont propres à chaque élément d'un accélérateur. Ils doivent donc être implémentés comme méthode virtuelle, qu'hériteront les sous-classe d'élément, dans la super classe Élement : en effet, elles seront redéfinis plus tard dans les sous-classe des éléments droits et élément courbes, ce qui fait des classes élément, élément courbe et élément droit des classes virtuelles qui ne peuvent donc pas être instanciées ce qui est logique : ce ne sont pas de "vrais" élément d'un accélérateur mais seulement des "types" ou "catégorie" auxquels les réels élément appartiendront.
De plus, le choix d'utilisé une méthode plutôt qu'un attribut est un choix évident (il serait même beaucoup trop compliqué de l'implémenter en attributs)  puisque chaque champs magnétiques d'un élément est calculé différemment d'un autre et l'implémentation logique est donc la redéfinition d'une méthode virtuelle prenant la position d'une particule en argument et retournant le champ magnétique B que subit la particule à cette position.

QUESTION P6.3
Oui nous avons représenté le centre de courbure d'un élément droit au travers d'une méthode protégée ne prenant aucun argument (le calcule n'utilise que les attributs d'un élément courbe : position d'entrée, position de sortie, rayon de courbure ainsi que le troisième vecteur de la base cartésienne orthonormée), qui ne modifie pas les attributs de l'instance courante (const) et qui retourne un vecteur3D indiquant la position du centre de courbure.

QUESTION P6.4
NSM JE TE LA LAISSE EHEH

QUESTION P7.1
La classe Accélérateur doit pour l'instant simuler le système physique qu'est l'accélérateur de particule. Cette classe a donc besoin d'une collection de particules et d'une collection d'éléments (courbe, droit, dipôles..) comme attributs privés afin de part la suite simuler des interactions entre elle les particules ainsi que l'évolution de celles-ci dans les éléments de l'accélérateur. Ces collections seront contenues dans un tableau dynamique de type vector.
Afin de pouvoir visualiser l'évolution de cet accélérateur, une interphase texte est requise pour l'instant (interphase graphique pour plus tard). La façon  la plus pratique d'implémenter cette simulation est de créer une méthode affiche publique dans l'accélérateur. Cette méthode affiche fait donc une itération sur chaque éléments et particules qu'elle contient et affiche leur attributs pertinents. 
Cette fonction affiche (pour une meilleure visibilité et logique du code) utilise les fonctions affiche des éléments et des particules implémentée dans leurs propres classes.
Enfin, il est nécéssaire que la collection d'élément soit un tableau de pointeurs sur des éléments afin d'utiliser le polymorphisme pour afficher soit un dipôle, soit un quadruple, soit une section droite.
Nous avons décidé d'utiliser aussi un tableau de pointeurs sur des particules pour la collection de particules. Il est en effet plus rigoureux de l'implémenter comme ça au vu de possibles sous-classes de particules (dans un projet plus poussé par exemple).

QUESTION P7.2
QUESTION P9.1
QUESTION P9.2
QUESTION P9.3
QUESTION P11.1

